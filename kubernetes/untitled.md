---
description: Здесь я пишу свои заметки о изучении kubernetes в форме вопросов и ответов
---

# Kubernetes answers and questions

### GETTING STARTED

**Что такое version skew?**  
 Так как k8s придерживается семантического версионирования  
 \([https://semver.org/lang/ru/](https://semver.org/lang/ru/)\) то его компоненты должны иметь  
 совместимость в пределах нескольких предыдущих минорных версий. Скажем kube-apiserver имеет совместимость в пределах одной минорной версии \(т.е. версия 1.13 совместима с 1.12, но не  
 1.11\). Kube-apiserver имеет высочайший приоритет. то есть ни одна программа \(kubelet,kubectl,kube-\*\) ни должна иметь версию выше его.

**Что такое cgroup менеджеры?**  
 В линукс дистрибутивах, где init процессом выступает systemd, он же является cgroup менеджером \(ему выделяется корневая cgroup\). Контрольные группы служат для ограничения ресурсов, потребляемых процессами. Однако мы можем сконфигурировать чтобы kubelet и container runtime использовали cgroupfs. В таком случае в нашей системе будет 2 cgroup менеджера. Бывают случаи связанные с недостатком ресурсов, когда системы с двумя менеджерами становятсяя нестабильными. Чтобы избежать этого, рекомендуется использовать systemd менеджер для всего.  
 Как это сделать - добавить в `daemon.json` докера следующую строчку:  
 `"exec-opts": ["native.cgroupdriver=systemd"]`

**Чем можно установить k8s кластер?**  
 Есть различные утилиты -

* kubeadm - самая старейшая
* kops
* kubespray - набор ansible плейбуков

**Что такое container runtime, используемый нашим k8s кластером, и где его найти?**  
 Container runtime может быть любой CRI совместимый runtime - docker \(runc\), rkt, cri-o, containerd, frakti. Cri-O в отличие от containerd более легковесный. Сontainerd в свою очередь, полностью реализует спецификацию OCI. Cri-O как и runc просто запускает контейнеры.  
 Посмотреть container runtime :  
 `kubectl get nodes -o wide | less -S`

**Что такое resources, workloads?**  
 В k8s все является обьектом. Ресурс - это обьект k8s записанный в кластер. \(К примеру есть пользователи и группы, которые являются обьектами k8s, но не являются ресурсами\). Ресурс, запускающий контейнер называется workloads.

### **CONCEPTS**

Что такое PLEG \(Pod Lifecycle Event Generator\)?  
 Компонент k8s, который приводит текущее состояние кластера к желаемому.

**Что такое контроллеры в контексте k8s?**  
 Контроллеры асинхронно активируют ресурсы после их сохранения в кластере k8s. Контроллеры запускают reconciles \(cверка, согласование\) для приведения наблюдаемого состояния кластера к желаемому. Контроллеры не делают реконсиляцию по эвентам \(т.е. если один под прошел какое то количество эвентов, то при масштабировании до 2х, второй под должен пройти такое же\). Deployment контроллер создает/удаляет ReplicaSets, ReplicaSet контроллер создает/удаляет поды, Scheduler \(Controller\) пишет ноды в поды. Контроллеры приводят в действие ресурсы, после того как они записаны в k8s. Потом они запускают reconciles из events. \(events также являются ресурсами k8s\).

**Для чего нужен kubelet?**  
 Для запуска подов \(или для запуска control plane, т.к. control plane является набором статик подов \).

**Что такое overlay network?**  
 По сути, это плоская сеть поверх сущ. топологии \(которая может быть витиеватой и сложной\). Т.е. мы видим картину подов, каждый имеет свой ip, \(к пример 10.X.X.1, 10.X.X.2, 10.X.X.3, 10.X.X.4\) и это говорит нам как будто бы эти поды работают на одной ноде, в одной подсети, но в тоже время поды 10.X.X.3, 10.X.X.4 могут находится за кучей свитчей и роутеров в другой LAN или даже WAN сети\).

**В чем разница между deployment, statefulset и daemonset?**  
 Deployment при масштабировании будет создавать поды на тех нодах где есть ресурсы и нет taints \(к примеру мастер нода\). Deployment больше подходит для stateless приложений. Daemonset по дизайну создает поды строго на разных нодах \( к примеру это могут быть агенты мониторинга/логгинга\). Stateful set похож на deployment но используется для приложений которым нужна связь между собой \(или они должны знать друг о друге\). Если даже поды переподнимутся на других хостах, stateful set поддерживает уникальную сущность этих подов \(hostname, IP adress итд\). Stateful set больше подходит для stateless приложений.

**Как удалить ноду из кластера \(с cni Weave\)?**  
 Удаление самой ноды:  
 `kubectl drain <node_name>`  
 `kubectl delete node <node_name>`  
 Удаление созданных weave интерфейсов :  
 `weave launch weave status weave reset`  
 Удаление правил iptables созданных weave и kube-proxy \(выбрать все на KUBE\* \_\_WEAVE\* и DOCKER\*\):  
 `iptables -L`  
 Или вообще удалить все:  
 `for i in $(iptables -S | awk '{print $2}' | uniq ); do iptables -F $i \n && iptables -Z $i && iptables -X $i; done`

**В чем отличие Role от Clusterrole?**  
 Clusterrole не namespaced

**Что такое Node авторизация ?**  
 Авторизация вида Node - режим авторизации запросов к API  
 \(к kube-apiserver\) которые делает kubelet. Авторизатор Node позволяет kubelet делать операции  
 чтения:

* services
* endpoints
* nodes
* pods
* secrets
* configmaps
* persistent volumes
* persistent volume claims  записи:  nodes and node status  pods and pod status  events  Чтобы быть авторизованным при помощи Node, kubelet должен иметь credential, в котором говорится что он состоит в группе system:nodes и имеет имя system:node:&lt;node\_name&gt;.

**Что такое static pods?**  
 Это поды управляемые напрямую кубелетом \(а не через kube-apiserver\). Свойства static pods:

* Не управляются через control plane
* Нет healthchecks для контейнеров в static pods \(рестартует их кубелет\)

**Что такое bootstrap tokens и для чего нужны?**  
 Для присоединения ноды к control plane нужен токен генерирумый коммандой `kubeadm init`. \(Сам токен можно посмотреть коммандой `kubeadm token list`\). Он входит в группу `system:bootstrappers:kubeadm:default-node-token`. `discovery-token-ca-cert-hash` не меняется. Он является sha256sum нашего CA сертификата. Его можно получить двумя способами :  
 `kubeadm token create --print-join-command`  
 `openssl x509 -in /etc/kubernetes/pki/ca.crt -noout -pubkey | openssl rsa -pubin -outform DER 2>/dev/null | sha256sum | cut -d' ' -f1`

**Что такое weave и как он работает?**  
 Weave Net создает новую L2 сеть используя возможности ядра linux. Хосты W называются пирами \(или роутерами\). Каждый пир по умолчанию имеет MAC адрес вместо имени. Демон weaved настраивает сеть и управляет маршрутизацией между машинами. Подключится к сети можно с помощью cni плагина, который запускается как отдельный процесс. Для контейнеров сеть Weave напоминает большой ethernet свитч. W роутит пакеты 2 методами: fast datapath \(работает полностью в kernel space\) sleeve \(пакеты предназначенные для удаленных контейнеров захватываются ядром и обрабатываются в userspace, далее передаются через udp. на принимающей стороне они опять обрабатываются ядром, которое в свою очередь передает их своим контейнерам\). W роутеры узнают на каком хосте находится конкретный mac адресс. Потом с учетом топологии они принимают решение как роутить конкретный пакет. Фреймы в режиме sleeve имеют следующий вид:

Роутер использует batching если фреймы пересылаются слишком быстро и будет старатся вместить как можно больше фреймов в udp пакет. Взаимодействие между пирами происходит 2 способами:  
 a\) spanning-tree based broadcast  
 b\) a neighbor gossip  
 Сообщения о топологии посылаются в след случаях :

* Если новый пир появился в сети ему отсылается вся топология сети, и делается broadcast инкрементального обновления о 2х узлах на концах этого пира \(т.к. каждый пир у нас соединен с предыдущим и следующим\).
* Когда сообщение помечено ESTABLISHED \(т.е. новый пир может получать UDP траффик\) делается broadcast всего лишь информации о новом пире.
* Когда соединение разорвано, делается broadcast лишь этой информации.
* Периодически по таймеру, соседи сплетничают друг с другом о всей топологии. Порядок выбора зависит рандомно. Это делается для того чтобы уменьшить вероятность что предыдущие броадкасты не могли дойти до каких то пиров.  Т.к. топология не изменяется моментально, некоторые пиры могут иметь устаревшее видение. W роутер является userspace процессом, поэтому он проходит извилистый путь через ядро и обратно на пути к назначению. Fast datapath использует модуль ядра Openvswitch. С помощью этого модуля, W роутер говорит ядру как обрабатывать пакеты. Это уменьшает переключения контекста \(с user- в kernel- space\) и уменьшает задержки и расход CPU. Пакет идет напрямую в ядро, где к нему добавляется VxLAN заголовок \(если сетевая поддерживает акселерацию VxLAN\). Для работы Openvswitch datapath требуется kernel&gt;3.12 W пиры взаимодействуют друг с другом используя и tcp и udp.

**Что такое cfssl?**  
 Cloudflare SSL \(cfssl\) утилита для работы с ssl сертификатами. Использует json формат и довольно проще чем openssl.

**В чем разница между Replication Controller и Replica Set.**  
RS требует наличие поля  selector. Это поле позволяет RS  управлять подами, которые не были созданы как часть RS. Например, любые поды созданные с  
labels, которые совпадают с matchLabels будут управляться при помощи RS. Это могут быть поды созданные вручную при помощи RC, и тд.  
Увеличение количества подов можно сделать тремя способами:  
1\) Обновить файл манифеста и вызвать kubectl replace -f &lt;file\_name.yaml&gt;  
2\) kubectl scale replicas=N -f &lt;file\_name.yaml&gt;  Это автоматически обновит файл манифеста  
3\) kubectl scale replicas=N replicaset &lt;rs\_name&gt; Это обновит число подов в RS, но не обновит файл манифеста

**Taints и tolerations, что это вообще такое?**  
Taint это свойство ноды. Оно означает что на ней могут планироваться поды, которые имеют toleration к этой ноде. TODO: описать подробно

**Что такое Node selector и в чем его отличие от labels**

 **Что такое node affinity/antiaffinity**

  
****

